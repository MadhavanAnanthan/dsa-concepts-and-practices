Two Pointers
   ├── Opposite Ends (Bidirectional)
   │     ├── Pair Sum / Two Sum (Sorted)--
   │     ├── Triplets (3-Sum)--
   │     ├── Quadruplets (4-Sum)
   │     ├── K-Sum (Generalized using recursion)
   │     ├── Closest Sum--same as 3 sum
   │     ├── Max Area / Container With Most Water
   │     ├── Trapping Rain Water (Two pointers approach)
   │     ├── Reverse Array / String--
   │     ├── Check Palindrome--
   │     ├── Valid Palindrome II (remove a char)--
   │     ├── Compare Strings (skip spaces, punctuation)
   │     ├── Merge Two Sorted Arrays (from end)--
   │     └── Dutch National Flag (variant)
   │
   ├── Same Direction (Forward Only)
   │     ├── Remove Duplicates (sorted array)
   │     ├── Move Zeroes
   │     ├── Segregate Even–Odd
   │     ├── Partition Array Around Pivot
   │     ├── Sort Colors (DNF - 0,1,2)
   │     ├── Remove Element (value-based deletion)
   │     ├── Longest Increasing Subarray
   │     ├── Minimum Difference Pair
   │     ├── Squaring a Sorted Array (merge two sorted sides)
   │     ├── Merge Intervals (two pointer scan)
   │     ├── Interval Intersection
   │     ├── Compress String (in-place)
   │     ├── Find Missing Numbers (cyclic sort variants)
   │     └── Next Permutation (scanning from end)
   │
   ├── Sorting + Two Pointers
   │     ├── Classic 3-Sum
   │     ├── Classic 4-Sum
   │     ├── K-Sum (general pattern)
   │     ├── Closest Sum
   │     ├── Smaller Than Current Count
   │     ├── Count Pairs With Difference K
   │     ├── Two Pointers on Sorted Intervals
   │     ├── Two Pointers on Prefix Sums
   │     └── Remove Duplicates From Sorted List (LL)
   │
   ├── Fast–Slow (Tortoise–Hare)
   │     ├── Cycle Detection in Linked List
   │     ├── Detect Cycle Start Node
   │     ├── Middle of Linked List
   │     ├── Happy Number (cycle on digits sum)
   │     ├── Find Duplicate Number (cycle in array)
   │     ├── Length of Cycle
   │     ├── Reorder Linked List (mid + reverse + merge)
   │     ├── Palindrome Linked List (mid + reverse + compare)
   │     ├── Remove N-th Node From End (k distance)
   │     ├── Circular Array Loop detection
   │     └── Slow–Fast in Sliding Window Problems
   │
   ├── Expand Around Center
   │     ├── Longest Palindromic Substring
   │     ├── Count Palindromic Substrings
   │     ├── Palindrome Partitioning Pre-check
   │     └── Even/Odd length center expansions
   │
   ├── Window Boundary Pointers (Not sliding window)
   │     ├── Shrink & Expand Edges independently
   │     ├── Minimum Operations to Reduce X to Zero
   │     ├── Maximum Producing Subarray (product focus)
   │     ├── Longest Nice Subarray (bitwise constraints)
   │     └── Multiplication Window Patterns
   │
   ├── Meet-in-the-Middle (Related)
   │     ├── Split Array into two halves and two-pointer combine
   │     ├── Subset Sum Optimization
   │     └── Hard DP optimized using two-pointer merging
Sliding Window
   ├── Fixed Window Size
   │     ├── Maximum Sum Subarray (size k)
   │     ├── First Negative Number in Window
   │     ├── Count Anagrams (frequency match)
   │     ├── Max/Min in every window (Deque)
   │     ├── Number of subarrays with size k conditions
   │     └── K-radius averages
   │
   ├── Variable Window Size (Expand–Shrink)
   │     ├── Longest Substring Without Repeating Characters
   │     ├── Longest Substring With K Distinct Characters
   │     ├── Minimum Window Substring
   │     ├── Minimum Window to remove to satisfy condition
   │     ├── Smallest Subarray with Sum ≥ Target
   │     ├── Longest Subarray with Sum ≤ K
   │     ├── Subarray Product < K
   │     └── Longest Subarray with Ones after replacement
   │
   ├── Dynamic Frequency Window
   │     ├── Character frequency maps
   │     ├── Valid anagram window
   │     ├── Count substrings with same frequency
   │     ├── Character replacement window
   │     └── Sliding window with counters & matches
   │
   ├── Multiplicative / Division Window
   │     ├── Subarray product < K
   │     ├── Count of subarrays with exact product
   │     ├── Max product subarray (window variant)
   │     └── Window with prime factors
   │
   ├── Bitwise Window (Advanced)
   │     ├── Longest Nice Subarray (AND == 0)
   │     ├── XOR-based shrinking windows
   │     ├── Windows with bit masks
   │     └── Sliding window for binary arrays
   │
   ├── Deque-based Window
   │     ├── Max in sliding window
   │     ├── Min in sliding window
   │     ├── Maximum absolute difference
   │     └── Two deque technique
   │
   ├── Advanced Hybrid Windows
   │     ├── Window + Sorting (frequency match)
   │     ├── Window + Prefix sums
   │     ├── Window + Greedy
   │     ├── Window + Two pointers + Hashing
   │     └── Window + Binary search (min window size)
Binary Search
   ├── Classic Binary Search
   │     ├── Search target in sorted array
   │     ├── First occurrence
   │     ├── Last occurrence
   │     ├── Count occurrences
   │     ├── Upper bound / Lower bound
   │     └── Floor & Ceil of element
   │
   ├── Binary Search on Answer (Advanced)
   │     ├── Minimum capacity to ship packages
   │     ├── Koko Eating Bananas
   │     ├── Min speed / max speed problems
   │     ├── Smallest divisor given threshold
   │     ├── Allocate books / Painters partition
   │     ├── Aggressive cows / place cows
   │     ├── Split array largest sum
   │     └── Minimize maximum of array
   │
   ├── Search in Rotated Sorted Array
   │     ├── Rotated array normal search
   │     ├── Search with duplicates
   │     ├── Find min in rotated array
   │     └── Find pivot element
   │
   ├── Binary Search on Real Numbers
   │     ├── Sqrt (Newton/binary)
   │     ├── Cube root / nth root
   │     ├── Precision-based binary search
   │     └── Maximize average subarray
   │
   ├── Binary Search on 2D Arrays
   │     ├── Search Matrix I
   │     ├── Search Matrix II (staircase)
   │     ├── Peak in 2D matrix
   │     └── Flattened binary search
   │
   ├── Binary Search on Monotonic Functions
   │     ├── Predicate-based binary search
   │     ├── Feasibility check problems
   │     ├── Minimum K to satisfy condition
   │     └── Binary search on DP states (rare)
   │
   ├── Search in Infinite Array
   │     └── Exponential search + BS
Linked List
   ├── Basic Operations
   │     ├── Insert head/tail/middle
   │     ├── Delete node
   │     ├── Search node
   │     ├── Reverse list
   │     ├── Find length
   │     └── Merge two lists
   │
   ├── Two Pointers on Linked List
   │     ├── Middle of list
   │     ├── Cycle detection
   │     ├── Cycle length
   │     ├── Detect cycle start
   │     ├── Remove Nth from end
   │     └── Palindrome linked list
   │
   ├── Sorting Linked List
   │     ├── Merge sort
   │     ├── Quick sort
   │     ├── Insertion sort
   │     └── Sort using min-heap
   │
   ├── Advanced LL Transformations
   │     ├── Reorder list
   │     ├── Rotate list
   │     ├── Swap nodes in pairs
   │     ├── Reverse nodes in K-group
   │     └── Delete duplicates
   │
   ├── Flattening & Nested Lists
   │     ├── Flatten multilevel list
   │     ├── Flatten sorted lists
   │     ├── Merge K lists
   │     └── Intersection of two lists
   │
   ├── Doubly Linked List
   │     ├── Insert/delete
   │     ├── Iterator patterns
   │     ├── Browser history problem
   │     ├── LRU Cache
   │     └── LFU Cache
Stack
   ├── Classic Stack Problems
   │     ├── Balanced parentheses
   │     ├── Valid parentheses string
   │     ├── Evaluate postfix
   │     ├── Evaluate prefix
   │     ├── Infix → Postfix conversion
   │     └── Simplify path
   │
   ├── Monotonic Stack
   │     ├── Next Greater Element
   │     ├── Next Smaller Element
   │     ├── Previous Greater Element
   │     ├── Previous Smaller Element
   │     ├── Stock Span
   │     └── Largest Rectangle in Histogram
   │
   ├── Stack + String Processing
   │     ├── Decode string
   │     ├── Remove adjacent duplicates
   │     ├── Minimum remove to make valid
   │     └── Reverse substrings inside parentheses
   │
   ├── Stack for DP / Greedy
   │     ├── Asteroid collision
   │     ├── Daily temperatures
   │     ├── Remove K digits
   │     └── Build monotonic increasing sequence
   │
   ├── Two Stack Implementations
   │     ├── Queue using stacks
   │     ├── Min stack
   │     ├── Max stack
   │     └── Time-based stack pop
Queue
   ├── Simple Queue Patterns
   │     ├── Circular queue
   │     ├── Queue using arrays
   │     ├── Queue using linked list
   │     └── Queue using 2 stacks
   │
   ├── Deque (Double Ended Queue)
   │     ├── Max of every window
   │     ├── Min of every window
   │     ├── Sliding window optimizations
   │     └── Palindrome check using deque
   │
   ├── Priority Queue / Heap-based
   │     ├── K largest elements
   │     ├── K smallest elements
   │     ├── Median in data stream
   │     └── Merge K sorted lists
   │
   ├── BFS (Queue)
   │     ├── Tree BFS
   │     ├── Graph BFS
   │     ├── Matrix BFS
   │     ├── Shortest path in unweighted graph
   │     ├── Number of islands (BFS version)
   │     └── Rotten oranges
   │
   ├── Simulation Problems
   │     ├── Printer queue
   │     ├── Task scheduler
   │     ├── Moving average
   │     ├── Rate limiter design
   │     └── Hit counter
Hash Table
   ├── Frequency Counting
   │     ├── Character frequency
   │     ├── Word frequency
   │     ├── Count pairs with equal elements
   │     ├── Most frequent element
   │     ├── Longest substring with constraints
   │     └── Grouping anagrams (freq map)
   │
   ├── Hashing for Lookup
   │     ├── Contains duplicate
   │     ├── Two sum (hash map)
   │     ├── Check subset / superset
   │     ├── Intersection of arrays
   │     └── Union of arrays
   │
   ├── Hashing for Index Tracking
   │     ├── Two sum (index map)
   │     ├── First unique character
   │     ├── Subarrays with target sum
   │     ├── Longest repeating substring
   │     └── Sliding window with freq map
   │
   ├── Prefix Sum + Hashing
   │     ├── Subarray sum = K
   │     ├── Count subarrays divisible by K
   │     ├── Longest subarray with 0 sum
   │     ├── Subarray with equal 0s & 1s
   │     ├── Subarray with equal letters
   │     └── XOR prefix problems
   │
   ├── Hash Set Patterns
   │     ├── Find missing number
   │     ├── Find duplicate number
   │     ├── Longest consecutive sequence
   │     ├── Unique email addresses
   │     └── Valid Sudoku
   │
   ├── Hash Map + Two Pointers / Window
   │     ├── Length of longest substring
   │     ├── K distinct characters
   │     ├── Smallest window substring
   │     ├── Remove duplicates (window)
   │     └── Compare freq with target
   │
   ├── Custom Hashing Problems
   │     ├── Hashing pair of numbers
   │     ├── Hashing tuple/struct
   │     └── Rolling hash (Rabin–Karp)
   │
   ├── Advanced: Hashing for DP
   │     ├── Memoization table
   │     ├── Dictionary word break
   │     └── Caching recursion results
Trees
   ├── Tree Traversals
   │     ├── Preorder (root-left-right)
   │     ├── Inorder (left-root-right)
   │     ├── Postorder (left-right-root)
   │     ├── Level-order traversal (BFS)
   │     └── Zig-zag level order
   │
   ├── Depth & Height
   │     ├── Max depth
   │     ├── Min depth
   │     ├── Balanced binary tree
   │     └── Diameter of binary tree
   │
   ├── Path Problems
   │     ├── Path sum (root-to-leaf)
   │     ├── Path sum II (all paths)
   │     ├── Maximum path sum
   │     ├── Longest same-value path
   │     └── Root to leaf binary number sum
   │
   ├── Tree Construction
   │     ├── Build from preorder + inorder
   │     ├── Build from inorder + postorder
   │     ├── Build full binary tree
   │     ├── Construct from level order
   │     └── Deserialize/serialize tree
   │
   ├── Tree Modification
   │     ├── Invert binary tree
   │     ├── Prune tree
   │     ├── Flatten tree
   │     ├── Merge two binary trees
   │     └── Delete nodes and return forest
   │
   ├── Views of Binary Tree
   │     ├── Left view
   │     ├── Right view
   │     ├── Top view
   │     ├── Bottom view
   │     └── Vertical order traversal
   │
   ├── Tree Counts / Combinatorics
   │     ├── Count complete tree nodes
   │     ├── Unique binary trees (Catalan)
   │     └── Perfect binary tree properties
   │
   ├── Special Trees
   │     ├── N-ary tree traversals
   │     ├── Trie (prefix tree)
   │     ├── Segment tree
   │     └── Fenwick tree (Binary Indexed Tree)
BST
   ├── BST Properties
   │     ├── All left < root < all right
   │     ├── Inorder gives sorted list
   │     ├── BST search
   │     ├── Find min / max
   │     └── Floor & ceil in BST
   │
   ├── Insertion & Deletion
   │     ├── Insert node
   │     ├── Delete node
   │     ├── Replace with inorder successor
   │     └── Replace with predecessor
   │
   ├── BST Traversals
   │     ├── Inorder (sorted)
   │     ├── Preorder for building
   │     └── Reverse inorder (Kth largest)
   │
   ├── Kth Element Problems
   │     ├── Kth smallest
   │     ├── Kth largest
   │     ├── Find median
   │     └── Two sum in BST
   │
   ├── Validate BST
   │     ├── Recursion with bounds
   │     ├── Inorder (must be sorted)
   │     └── Subtree constraints
   │
   ├── Lowest Common Ancestor (LCA)
   │     ├── LCA of BST
   │     ├── LCA in general tree
   │     └── Compare values with root
   │
   ├── BST Transformations
   │     ├── Convert sorted array → BST
   │     ├── Convert sorted list → BST
   │     ├── Balance unbalanced BST
   │     ├── Increasing order search tree
   │     └── BST → Greater Sum Tree
Heap
   ├── Min-Heap Basics
   │     ├── Insert
   │     ├── Pop min
   │     ├── Heapify
   │     └── Build heap
   │
   ├── Max-Heap Basics
   │     ├── Find k largest
   │     ├── Sort (Heap sort)
   │     └── Median maintenance
   │
   ├── Priority Queue Problems
   │     ├── K closest elements
   │     ├── K frequent elements
   │     ├── Top-K streaming numbers
   │     ├── K pairs smallest sum
   │     ├── Reorganize string
   │     └── Task scheduler
   │
   ├── Heap + Two Pointers
   │     ├── Merge K sorted lists
   │     ├── Smallest range covering elements from K lists
   │     └── Streaming next smallest item
   │
   ├── Heap + Graph
   │     ├── Dijkstra’s algorithm
   │     ├── Prim’s MST
   │     └── A* search algorithm
   │
   ├── Double Heap (Two Heaps)
   │     ├── Running median
   │     ├── Sliding window median
   │     └── Balance heaps technique
   │
   ├── Advanced Heaps
   │     ├── Fibonacci heap (concept)
   │     ├── Leftist heap
   │     ├── Binomial heap
   │     └── Indexed priority queue
Graph Basics
   ├── Graph Representations
   │     ├── Adjacency list
   │     ├── Adjacency matrix
   │     ├── Edge list
   │     ├── Weighted adjacency list
   │     └── Bidirectional graph build
   │
   ├── Types of Graphs
   │     ├── Directed / Undirected
   │     ├── Weighted / Unweighted
   │     ├── Cyclic / Acyclic
   │     ├── DAG (Directed Acyclic Graph)
   │     ├── Trees as graphs
   │     └── Complete graphs
   │
   ├── Traversal Basics
   │     ├── BFS
   │     ├── DFS
   │     ├── DFS recursive
   │     ├── DFS using stack
   │     └── BFS for layers
   │
   ├── Cycle Detection
   │     ├── Undirected graph using DFS
   │     ├── Undirected graph using Union-Find
   │     ├── Directed graph using DFS
   │     ├── Directed graph using Kahn’s algorithm
   │     └── Back-edge detection
   │
   ├── Connected Components
   │     ├── Count connected components
   │     ├── Islands in grid
   │     ├── Provinces problem
   │     └── Number of enclaves
   │
   ├── Bipartite Graph
   │     ├── BFS coloring
   │     ├── DFS coloring
   │     └── Detect odd cycle
   │
   ├── Union-Find (Disjoint Set)
   │     ├── Find with path compression
   │     ├── Union by rank/size
   │     ├── Detect cycle
   │     ├── Count components
   │     └── Graph connectivity queries
Graph Traversal
   ├── BFS (Breadth First Search)
   │     ├── Shortest Path in Unweighted Graph
   │     ├── Level Order Traversal (Tree / Graph)
   │     ├── Connected Components (BFS)
   │     ├── Bipartite Graph Check
   │     ├── Cycle Detection (Undirected)
   │     ├── Grid BFS (Matrix)
   │     │      ├── Rotten Oranges
   │     │      ├── Knight Moves
   │     │      └── Flood Fill
   │     ├── Multi-Source BFS
   │     └── BFS on Weighted Graph (0–1 BFS)
   │
   ├── DFS (Depth First Search)
   │     ├── Connected Components
   │     ├── Cycle Detection (Directed)
   │     ├── Cycle Detection (Undirected)
   │     ├── Detect Back-Edges / Forward-Edges
   │     ├── Island Counting (Grid DFS)
   │     ├── Number of Enclaves
   │     ├── Articulation Points (Tarjan)
   │     ├── Bridges in Graph (Tarjan)
   │     └── Topological Sort (DFS)
   │
   ├── Topological Sorting
   │     ├── DFS-Based Topo Sort
   │     ├── Kahn’s Algorithm (BFS)
   │     ├── Detect Cycle in Directed Graph
   │     ├── Course Schedule I/II
   │     └── Alien Dictionary
   │
   ├── Union-Find (Used in Graph Problems)
         ├── Find + Union
         ├── Union by Rank
         ├── Path Compression
         ├── Cycle Detection (Undirected)
         ├── Redundant Connection
         ├── Number of Islands (UF)
         └── Evaluate Division (Weighted UF)
Graph Algorithms
   ├── Shortest Path Algorithms
   │     ├── Dijkstra’s Algorithm
   │     │      ├── PQ (Min-Heap) Version
   │     │      ├── Adjacency List Version
   │     │      └── Grid Dijkstra
   │     ├── Bellman-Ford
   │     │      ├── Negative Edges
   │     │      └── Detect Negative Cycle
   │     ├── Floyd–Warshall
   │     │      ├── All-Pairs Shortest Path
   │     │      └── Negative Cycle Check
   │     ├── 0–1 BFS (Deque)
   │     └── Multi-Source Shortest Path
   │
   ├── Minimum Spanning Tree (MST)
   │     ├── Kruskal’s Algorithm
   │     │      ├── Sorting Edges
   │     │      ├── Union-Find
   │     │      └── Cycle Avoidance
   │     ├── Prim’s Algorithm
   │     │      ├── Min-Heap Version
   │     │      └── Dense Graph Version
   │     └── Applications of MST
   │
   ├── Strongly Connected Components (SCC)
   │     ├── Kosaraju Algorithm
   │     ├── Tarjan Algorithm
   │     └── Condensed DAG
   │
   ├── Advanced Graph Topics
   │     ├── Bridges (Critical Connections)
   │     ├── Articulation Points
   │     ├── Eulerian Path & Circuit
   │     ├── Hamiltonian Path (Backtracking)
   │     ├── Hopcroft–Karp (Bipartite Matching)
   │     └── Topological DP on DAG
   │
   └── Flow Algorithms (Optional Advanced)
         ├── Max-Flow (Edmonds–Karp)
         ├── Dinic’s Algorithm
         └── Min-Cut
Greedy Algorithms
   ├── Interval Scheduling
   │     ├── Activity Selection
   │     ├── Non-overlapping Intervals
   │     ├── Merge Intervals
   │     ├── Insert Interval
   │     ├── Meeting Rooms I/II
   │     └── Car Pooling
   │
   ├── Greedy + Sorting
   │     ├── Minimum Platforms
   │     ├── Assign Cookies
   │     ├── Gas Station
   │     ├── Jump Game I
   │     ├── Jump Game II
   │     ├── Maximum Units on Truck
   │     └── Largest Number from Array
   │
   ├── Greedy with Heaps
   │     ├── Connect Ropes
   │     ├── Reorganize String
   │     ├── Reduce Array Sum
   │     ├── K-Largest Elements
   │     └── Frequency Stack
   │
   ├── Graph + Greedy
   │     ├── Prim’s MST
   │     ├── Kruskal’s MST
   │     └── Dijkstra’s Algorithm
   │
   └── Greedy Patterns
         ├── Always Choose Local Optimal
         ├── Sort + Iterate
         ├── Min/Max Heap Choices
         └── Earliest End First
Dynamic Programming
   ├── DP Fundamentals
   │     ├── Memoization (Top-Down)
   │     ├── Tabulation (Bottom-Up)
   │     ├── State Transition
   │     ├── Space Optimization
   │     └── Subproblem Identification
   │
   ├── 1D DP
   │     ├── Fibonacci Variants
   │     ├── Climbing Stairs
   │     ├── House Robber
   │     ├── House Robber II
   │     └── Min Cost Climbing Stairs
   │
   ├── 2D DP
   │     ├── Grid Paths
   │     ├── Unique Paths I/II
   │     ├── Min Path Sum
   │     ├── Dungeon Game
   │     └── Cherry Pickup
   │
   ├── Subset DP
   │     ├── Subset Sum
   │     ├── Partition Equal Subset
   │     ├── Count Subsets
   │     └── Target Sum
   │
   ├── Knapsack Variants
   │     ├── 0/1 Knapsack
   │     ├── Unbounded Knapsack
   │     ├── Rod Cutting
   │     └── Coin Change I/II
   │
   ├── String DP
   │     ├── Longest Common Subsequence
   │     ├── Longest Common Substring
   │     ├── Edit Distance
   │     ├── Longest Palindromic Subsequence
   │     ├── Palindrome Partitioning
   │     └── Wildcard Matching / Regex
   │
   ├── DP on Subsequences
   │     ├── LIS (Longest Increasing Subsequence)
   │     ├── Russian Dolls
   │     ├── Max Sum Increasing Subsequence
   │     └── Longest Chain Pairs
   │
   └── DP on Trees
         ├── Tree DP Rooted at Node
         ├── Diameter of Tree
         ├── Max Path Sum
         ├── Count Paths
         └── Tree Coloring Problems
Backtracking
   ├── Permutations
   │     ├── Unique Permutations
   │     └── String Permutations
   │
   ├── Combinations
   │     ├── Combination Sum I
   │     ├── Combination Sum II
   │     └── Combinations (nCr)
   │
   ├── Subsets
   │     ├── All Subsets
   │     ├── Unique Subsets
   │     └── Subset Sum
   │
   ├── Classic Backtracking Problems
   │     ├── N-Queens
   │     ├── Sudoku Solver
   │     ├── Word Search
   │     ├── Rat in a Maze
   │     └── Generate Parentheses
   │
   ├── DFS + Backtracking
   │     ├── Paths in Graph
   │     ├── Hamiltonian Path
   │     └── Restore IP Addresses
   │
   └── Decision Tree Patterns
         ├── Choose/Not Choose
         ├── For-loop Recursion
         ├── Swap Recursion (perms)
         └── Backtrack with State Reset
Intervals
   ├── Merging
   │     ├── Merge Intervals
   │     ├── Insert Interval
   │     └── Employee Free Time
   │
   ├── Non-overlapping
   │     ├── Erase Overlap Intervals
   │     ├── Minimum Arrows to Burst Balloons
   │     └── Maximum Chain Length
   │
   ├── Scheduling
   │     ├── Meeting Rooms I
   │     ├── Meeting Rooms II
   │     ├── Car Pooling
   │     └── Task Scheduler
   │
   ├── Prefix/Timeline Methods
   │     ├── Sweep Line Algorithm
   │     ├── Event Sorting
   │     └── Min Platforms (Trains)
   │
   └── Interval Tricks
         ├── Sort by Start
         ├── Sort by End
         ├── Merge if Overlap
         └── Use Min-Heap for Room Count
Tries
   ├── Basic Trie
   │     ├── Insert Word
   │     ├── Search Word
   │     └── Starts With Prefix
   │
   ├── Trie Applications
   │     ├── Longest Common Prefix
   │     ├── Word Dictionary (with .)
   │     ├── Word Search II (Board + Trie)
   │     ├── Auto-Suggestion System
   │     └── Replace Words
   │
   ├── XOR Trie
   │     ├── Maximum XOR Pair
   │     ├── Max XOR of Number with Array
   │     └── Bitwise Trie Representation
   │
   ├── Suffix Trie (Advanced)
   │     ├── All Suffixes Storage
   │     └── Pattern Searching
   │
   └── Compressed Trie (Radix Tree)
         ├── Space-optimized Trie
         └── Prefix Trees for Dictionary
Segment Trees
   ├── Basics
   │     ├── Tree Construction
   │     ├── Range Query (Sum/Min/Max)
   │     └── Point Updates
   │
   ├── Lazy Propagation
   │     ├── Range Updates
   │     └── Range Queries
   │
   ├── Segment Tree Variants
   │     ├── Range Minimum Query (RMQ)
   │     ├── Range Sum Query (RSQ)
   │     ├── Range XOR Query
   │     └── Range GCD Segment Tree
   │
   ├── Fenwick Tree (Binary Indexed Tree)
   │     ├── Prefix Sum Tree
   │     ├── Point Update + Range Query
   │     └── Range Update + Point Query
   │
   └── Advanced Segment Trees
         ├── Merge Sort Tree
         ├── Persistent Segment Tree
         └── Segment Tree Beats
